use anyhow::{Context, Result};
use std::fs;
use std::io::ErrorKind;
use std::path::Path;

/// Types accepted by mozilla.cfg
#[derive(Clone, Copy)]
pub enum PrefValue {
    Bool(bool),
    Int(i64),
    Str(&'static str),
}

pub fn ensure_parent_dir(path: &str) -> Result<()> {
    if let Some(parent) = Path::new(path).parent() {
        fs::create_dir_all(parent).with_context(|| format!("create dir '{}'", parent.display()))?;
    }
    Ok(())
}

pub fn remove_file_silent(path: &str) -> Result<()> {
    match fs::remove_file(path) {
        Ok(_) => Ok(()),
        Err(e) if e.kind() == ErrorKind::NotFound => Ok(()),
        Err(e) => Err(e).with_context(|| format!("remove '{}'", path)),
    }
}

pub fn render_autoconfig_js() -> String {
    [
        r#"pref("general.config.filename", "mozilla.cfg");"#,
        r#"pref("general.config.obscure_value", 0);"#,
    ]
    .join("\n")
        + "\n"
}

pub fn render_mozilla_cfg(prefs: &[(&'static str, PrefValue)]) -> String {
    let mut out = String::from(
        "// Do NOT edit! This file will be overwritten on next run.\n// Generated by eZix.\n",
    );
    for (k, v) in prefs {
        out.push_str("defaultPref(\"");
        out.push_str(k);
        out.push_str("\", ");
        out.push_str(&format_pref_value(*v));
        out.push_str(");\n");
    }
    out
}

fn format_pref_value(v: PrefValue) -> String {
    match v {
        PrefValue::Bool(b) => b.to_string(),
        PrefValue::Int(i) => i.to_string(),
        PrefValue::Str(s) => format!("{:?}", s),
    }
}
